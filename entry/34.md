# Adobe AIR Advent Calendar 1日目: AIR for iOS / Android で API とやりとりしながらローカル DB に突っ込む話

[Adobe AIR Advent Calendar](http://www.adventar.org/calendars/182) 1日目、  
ということで書かせていただきます。[@__hage__](https://twitter.com/__hage__) です。

初日にしてみんながあまり興味なさそうなローレイヤーな話をします。

ゲームであったり、サービスのクライアントであったり  
サーバーとの通信が絡むようなアプリでは必然的にローカルへデータを保存する必要が出てきます。

AIR には最初から SQLite をデータベースとしてローカルにデータを保存する機能が備わっていますが、  
この機能は AIR for iOS / Android でも同様に使用することが出来ます。

しかし、インタラクティブ野郎たちからすれば厄介そうである  
この機能がちゃんと備わっているからこそ、  
AIR for ○○ が実案件ベースでいけばアプリを開発するプラットフォームとしての  
現実解足りうる存在になれている要因の一つと考えています。

というわけで、僕からは AIR for iOS / Android で API とやりとりしながらローカルの DB でどう管理するか、設計と実装を交えながら話をさせてもらえたらと思います。

## meta

- date: 2013-12-01 10:06:18
- slug: 34
- active: true

## content

## 前提: ORM の導入

API の数が多く、保存すべきデータの種類が多いような案件ですと  
生の SQLite をそのまま使用するのは効率がいいとはいえないので  
ここは素直に ORM を導入しましょう。

AIR 用の ORM はいくつかあるようですが、  
直近の案件では [AirRecord](https://code.google.com/p/airrecord/) というものを使用させていただきました。
この AirRecord は ActiveRecord パターンに基づき設計されているらしいので、
Rails や CakePHP などに慣れている方であればすぐ使えるのではと思います。

AirRecord 自体の使い方については、
既に幾つか記事がありますのでこの記事では割愛させてもらいます。
以下の記事などを参考にしてもらえればと思います。

> [ADB開発中！Adobe Developer Box 開発日記　連載4) AIRによるActiveRecordの実装 | デベロッパーセンター](http://www.adobe.com/jp/devnet/air/articles/adb_howto_develop_ria_part4.html)

ちなみに個人的には `airorm` が気になっているので機会があればこちらも試してみようと思っている次第です。

というわけで、ここからの話は何かしら ORM を導入した状態である前提で話を進めて行きます。

## ローレイヤー周りの設計

さて、通常設計の話といったら MVC がどうたらだとか、MVVM がどうたらだ  
という話が定石だとは思うのですが  
ことインタラクティブ性の強い案件ですと、  
MVC がそもそも限界が有るのでは説がささやかれていたりと色々あって  
要は理想通りに事は進まない、と言うのはご周知のとおりと思います。

ついでに言えば、実案件ですので MVC ガー だとか MVVM ガー という話の時にスルーされがちな  
ビジネスロジックからも目を背けることは出来ません。

じゃあ、ローレイヤー担当の自分は結局何を作ればいいの? という話になるかと思いますが、  
個人的には  
「ローカル側でも、サーバーサイドで提供されている API を再現する」  
ことに終始するのがよいのではないかなと思います。

最終的に全体から俯瞰すると、MVC だろうが MVVM だろうがなんでもいいんですが Model の部分の役割を担う  
ということになりますね。  
こうして文章にするとわりと普通のことに聞こえてしますが、  
漠然とした状況の中で、最終的な着地点をどこに定めておくかという意識をしっかり持つことは、設計の基本の一つではないかと思います。

実際には Model と、 Controller ないし ViewModel などが操作するインターフェイス部分を実装して行く形になります。

## 想定

一応今回はこんな API があると想定して話を進めたいと思います。  
沢山あっても話がややこしくなるのでごくごくシンプルです。

API として叩ける URL は以下。

```
[GET]       /users/            ユーザーのリストが返ってくる  
[GET]       /users/<int:id> 指定した ID のユーザーが返ってくる  
[POST]     /users/            新しくユーザーを作成する。  
[PUT]       /users/<int:id> 指定した ID のユーザー情報を更新する  
[DELETE] /users/<int:id> 指定した ID のユーザー情報を削除する
```

まぁよくある RESTful っぽくて CRUD を実装してるアレですね。  
この辺の知識は実装することはなくとも叩くことは皆さんあると思うので知っとくと良いと思います。

やりとりするメッセージのフォーマットは  msgpack と言いたいところですが  
フロントエンド界隈ではまだそこまで一般的とも言えない気もするので  
まぁ今回は JSON にしておきましょう。

## Model の設計

前置きが随分長かったですがようやく本題、かつ AIR に関連する事柄です。

アプリの一番根っことなる Model の設計について考えてみましょう。

今回は冒頭にも書いた通り、ORM を使用する前提なので以下のように Model クラスを定義してみます。

<script src="https://gist.github.com/glassesfactory/44f082cec77d74ec48ee.js">{}</script>

色々と ORM 側の指示に則って書いています。  
Table にカラムとして定義したものをプロパティとしてもたせる必要があります。

この Model クラスのインスタンスから DB を直接操作することが出来ます。

Model の定義は一旦こんなもんです。

## Context の定義

数日前にサーバーとクライアントを繋ぎこむどうたら的な記事を書いた気がするのですが、  
その中で Context という手続きを抽象化したクラスを用意すると良いのではという話をした気がします。

というかこの記事が実質その続きだったりもするわけですが。

というわけで、 Model や API からの戻り値をうまい感じに取り回すために Context を定義してみましょう。

models.UserModel に対応するものとして、以下のように定義します。

<script src="https://gist.github.com/glassesfactory/84fdcd3d58887d98b5d2.js">{}</script>

僕の場合は Model と同様のプロパティを持たせています。  
一見すると、Model と全く同じ物をもたせているんだったら無駄なのでは?  
と思われがちですが、「Model インスタンスは直接 DB に対して操作可能である」ということを思い出してください。
ついうっかりクエリを実行するメソッドを叩かれた日には  
謎のクエリが走り続けるというバグを生みだしかねません。

演出側の人に対しては、そう言った泥臭い領域のことは極力隠蔽したいですよね。  
まさに、そのために用意したのが Context クラスであります。Context を使った手続きの流れとしては以下のようになります。

* Model を経由したローカル DB の検索結果などを一度 Context に変換。演出側に渡す
* スコアの更新など、データを新たに保存する必要が出てきた際は演出側で Context の値を更新
* Context ごとローカル API 側に投げてもらう
* ローカル API 側では、受け取った Context からサーバーへデータを送信
* 任意のタイミングでローカル DB の値も更新する作業を行う

と言った感じで、まさに文字通り文脈であったり手続きとしての役割を果たしてもらうわけです。

あとはここまで来たら Model 側に `getContext` だとか、`saveFromContext` だとかを用意しておくと捗ることでしょう。

## APIGateway の設計


各種 API に対する実装を書く前に、ネットワーク周りを整備しましょう。  
API に対してアクセスする時、  
直で URLLoader を書いてしまうと以下のような弊害が起こります。

* 暗号化や、OS 情報など通信時に必ず行うべき処理が発生した時、同じような処理を毎度書かなければならない
* 例えば通信に失敗するようなバグが出て来た時、本当に接続出来ているのかどうか確認すべき箇所が増えてしまう

それらを回避するために、  
API に対するアクセスを一元化するクラスとして APIGateway を用意します。

だいぶ歯抜けでいい加減ですが、URLLoader をラップするようなGateway としては以下の様な実装が想像できます。

<script src="https://gist.github.com/glassesfactory/08a87ac5e265361b7c4a.js">{}</script>

このように一箇所に集約してあげることで、
通信仕様周りで細かな変更があったとしても変更箇所が少なくて済みます。

Socket 通信が絡む場合は別途ご相談ください。

## ローカル API の定義

設計の項目で「ローカルでAPIを再現する」と書いた気がしますが  
その実装について考えてみます。

とりあえずクラスのインターフェイスだけを並べると以下のようなクラスが書き上がります。

<script src="https://gist.github.com/glassesfactory/ad2d350839f199d414d2.js"></script>

最終的に、演出を担当する方にはこのクラスを叩いてもらうことになるので  
メソッド名や引数については事前によく要望を聞いておくと良いでしょう。

API を実行した戻り値として IJob interface を実装したインスタンスを返しています。  
API が処理すべき内容を実際に処理するのがこの IJob になります。

## Job の定義

API の中で、実際に手続きを行うクラスをここでは Job と呼ぶことにします。  
なぜ、 API の中に直接書かないかというと以下のような理由が挙げられます。

* API としての URL は変わらなくても実質的な処理を変更する必要が出て来た時、Job クラスの差し替えで対応することができる。
* 何らかの理由で Job の実行失敗時、再度実行する必要がでても Job インスタンスごと再実行対象リストに回すことができる
* API の増減があっても各 Job が分離していることにより、依存関係が低くなるため影響が少ない

と言った理由が挙げられます。

全ての API Job の実装はさすがに書ききれないので、  
以下説明上必要っぽそうなものだけを。

<script src="https://gist.github.com/glassesfactory/3425112ac9432bfc277b.js"></script>

取得した結果をどのタイミングで DB に対して保存するかは作っているものの方向性と相談すると良いと思います。

通信に成功、失敗にかかわらずデータをどこかしらから取得することができたら  
それを Context に加工し、演出側に引き渡せばよいわけです。

大概はこの IJob の中にビジネスロジックを実行する処理を書き込むことになります。  
課金など、少し複雑になりがちな処理はあえて Job を二分割して実行するのもよいでしょう。

----------

という感じで、大分長くなりましたが地の底から華やかな世界へ  
データを届ける一通りの道筋が出来上がったかと思います。

今回はごくごく単純な API をベースにしてますが、  
実案件となると API の数は膨大になります。  
一定の規則に基づき、処理ごとにクラスを分けて作ることでローレイヤー担当者が増えた時にも  
作業分担をしやすいと思われます。

初日から大分濃厚かつあまり華やかではないネタになってしまいましたが  
実際の AIR for iOS / Android を使用した開発では避けては通れぬ道ですので、  
皆さんの参考に少しでもなれたらと思います。  
それでは。
